// 비트 이동 연산자 : >>, >>>, << 
package com.eomcs.basic.ex05;

public class Exam04_3 {
    public static void main(String[] args) {
      // >>> 비트 이동 연산자 사용법
      int i = 0b01101001; // 105
      // 00000000 00000000 00000000 01101001 = 105
      System.out.println(i); 
      // 00000000000000000000000011010101
      System.out.println(i >>> 1); // 00110100|1 => 52
      //x0000000000000000000000000110100|1
      //00000000000000000000000000110100
      System.out.println(i >>> 2); // 00011010|0 => 26
      //xx000000000000000000000000011010|01
      System.out.println(i >>> 3); // 00001101|0 => 13
      //xxx00000000000000000000000001101|001
      System.out.println(i >>> 4); // 00000110|1 => 6
      // 오른쪽으로 이동 후, 
      // 왼쪽 쪽 빈자리를 무조건 0으로 채운다
      // 오른쪽 경계를 넘어간 비트 : 자른다.

      
      i = 0b11111111_11111111_11111111_10101001; // -87
      System.out.println(i); 
      
      System.out.println(i >>> 1); 
      // 1_11111111_11111111_11111111_1010100|1   => 2147483604

     
      System.out.println(i >>> 2); 
      // 11_11111111_11111111_11111111_101010|01 => 1073741802

      System.out.println(i >>> 3); 
      // 111_11111111_11111111_11111111_10101|001 => 536870901
      
      System.out.println(i >>> 4);
      // 1111_11111111_11111111_11111111_1010|1001 => 268435450
  }
}
/*
* 
* -13
* 00001101 = 13
* 11110010
* +      1
* 11110011 = -13

*/
//오른쪽 이동
//- 1비트 이동은 나누기 2 한 것과 같은 효과를 준다.
//- 소수점이 있는 경우 그 수 보다 작은 정수 값이 된다.
//실무에서는 나눗셈 연산이 비용(cpu,시간)이 많이 들기에 소수점 이하까지 계산할 게 아니라면
//오른쪽 비트 이동 연산자를 사용하여 처리한다
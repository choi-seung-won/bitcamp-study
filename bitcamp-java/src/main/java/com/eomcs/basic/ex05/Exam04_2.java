// 비트 이동 연산자 : >>, >>>, << 
package com.eomcs.basic.ex05;

public class Exam04_2 {
    public static void main(String[] args) {
      
      // >> 비트 이동 연산자 사용법
// 오른쪽 이동
// - 1비트 이동은 나누기 2 한 것과 같은 효과를 준다.
// - 소수점이 있는 경우 그 수 보다 작은 정수 값이 된다.
//  실무에서는 나눗셈 연산이 비용(cpu,시간)이 많이 들기에 소수점 이하까지 계산할 게 아니라면
//  오른쪽 비트 이동 연산자를 사용하여 처리한다
        int i = 0b01101001; // 105
        // 00000000 00000000 00000000 01101001 = 105
        System.out.println(i); 
        // 00000000000000000000000011010101
        System.out.println(i >> 1); // 00110100|1 => 52
        //x0000000000000000000000000110100|1
        //00000000000000000000000000110100
        System.out.println(i >> 2); // 00011010|0 => 26
        //xx000000000000000000000000011010|01
        System.out.println(i >> 3); // 00001101|0 => 13
        //xxx00000000000000000000000001101|001
        System.out.println(i >> 4); // 00000110|1 => 6
        // 오른쪽으로 이동 후, 
        // 왼쪽 쪽 빈자리 : 원래 숫자와 같은 부호 값으로 채운다.
        //                  양수면 0, 음수면 1을 채운다.
        // 오른쪽 경계를 넘어간 비트 : 자른다.

        // 음수일 경우,
        // => 왼쪽 빈자리는 숫자의 부호비트로 채운다.
        //    음수니까 1로 채운다.
        // => 2로 나눈 후에 소수점이 있으면 
        //    그 수보다 더 작은 정수값이 되는 결과가 나온다. ex -2.5 > -3
        
        i = 0b11111111_11111111_11111111_10101001; // -87
        System.out.println(i); 
        System.out.println(i >> 1); 
        // 1_11111111_11111111_11111111_1010100|1   => -44 

        System.out.println(i >> 2); 
        // 11_11111111_11111111_11111111_101010|01 => -22

        System.out.println(i >> 3); 
        // 111_11111111_11111111_11111111_10101|001 => -11
        
        System.out.println(i >> 4);
        // 1111_11111111_11111111_11111111_1010|1001 => -6
    }
}
/*
 * 
 * -13
 * 00001101 = 13
 * 11110010
 * +      1
 * 11110011 = -13

 */
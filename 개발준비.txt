git / sun / cvs
eclipse,visual studio code
JDK(groalVM
gradle


PShell
iwr -useb get.scoop.sh | iex

graalvm install
-https://github.com/graalvm/graalvm-ce-builds/releases \\ java11
유니버설 가상버신 : JVM, Nodejs 포함
visual studio code VSCode
일반 및 개발 용 편집기
자바 스크립트로 만든 프로그램
크롬 웹 브라우저를 기반으로 실행됨.\
소스코드(java,html,.css,js)를 편집하기 위해 설치
일반 텍스트(txt,md)를  편집할 때도 사용한다.


c:\bitcamp\ - graalvm 압축해제
graalvm의 bin 폴더를 실행 경로(path)에 추가한다
path에 추가> 모든 디렉토리에서 해당 프로그램을 실행가능
미등록>해당 프로그램의 path정보가 없어 실행불가
등록방법 - 시스템 환경 변수 편집
graalvm 설치된 폴더 JAVA_HOME 이름으로 등록
자바 프로그램 중에서는 JDK(JRE)를 찾을 때 java_home으로 등록된 경로를 찾기 때문
jdk(java development kit)을 설치한 후에는 반드시 이 환경변수에 설치 디렉토리의 경로를 등록하라

통합 개발환경(IDE) eclipse
작업 폴더(workspace 디렉토리)/개발환경 설정
eclipse-inst-win64.exe execute
update

eclipse-enterprise version 설치 execute
워크스페이스 작업폴더 지정 : c:\users\user\eclipse-workspace
eclipse 사용 환경 설정
JDK 경로 확인 및 지정
window menu

eclipse preference java-nodes > installed jres jdk설치확인
java source code를 저장할 때 사용할 인코딩 규칙 설정 (general-workspace)txtfileencoding utf8

general-editors-text editors
기본편집기의 실행환경설정
displayed tab width=2 insert spaces for tabs = Yes
show print margin = Yes print number column = 100
show white space characters() = Yes
> configure visibility carrage return/line feed = No
Transparency level = 30

set web encoding
web > JSP/HTML/CSS Files>encoding utf8
general > appearance >colors and fonts
>"Basic">Text font


github upload(push)

github 저장소준비
회원가입
회원 인증 메일 확인
로그인
"bitcamp-study" 저장소 생성
개발pc에 github.com의 저장소 복제
github.com의 저장소복제


저장소 복제할 폴더 생성
c:\Users\user\git 폴더 생성
$(=sdk) git clone github_storage_address


git howtobasic
addfile
bitcamp-study\test1.txt 생성
git push


.git을 통하여 업로드/다운로드

로컬저장소에 백업 대상 목록작성: $ git add test1.txt
로컬저장소에 백업: $ git commit -m "저장하는이유"
로컬저장소의 내용을 git 서버에 업로드: $ git push


로컬 git user identify
*** Please tell me who you are.

Run

  git config --global user.email "you@example.com"
  git config --global user.name "Your Name"

to set your account's default identity.
Omit --global to set the identity only in this repository.


git add .(현재/하위폴더 모든변경점)


Fowler, Martin - Refactoring

https://github.com/kamranahmedse/developer-roadmap



hardware input > unix / linux shell script(bash,zsh,tsh,bsh) > cpu,ram,HDD > hardware(software driver) 

git input cmd > push (commit)
git output cmd > pull (checkout)

OS마다 사용하는 코드가다름


진수의 간략기록
ex)16진수/ 0xb6f0 > (0x/진수정의)전기신호 = cpu에게 명령하는방식, 2/16진수사용
명령어는 RandomAccessMemory 에저장

OS가 총괄하는 AP/CPU/computer 작동원리 
> HDD에 저장된 작성완료한 명령어input(cpu마다 명령어가 다름. 규격에 따른 작성 요구/CPU Instruction) 
> RAM에Loading(싣다) > CPU에전송 > RAM에 실행결과 저장 > 

clock(hz/Ghz) > 신호의 정의범주(신호 분간을 위한 범주/단위책정)단위
>Hz↑=사양이 증가할수록 전력소모증가 = 발열증가
>Hz를 낮추고 연산의 분산/멀티코어 채용


RandomAccessMemory = 8bit cell사용 2^7=128  ISO/IEC 646/ 2^8=256 ISO 8859 (ASCII American Standard Code for Information Interchange)


assembles language =/ machine language
assembly language (low level language) -> complier -> machine language


program excute >
c>compiler
source file 1 compiler A linux based machine lang
	  2 compiler B windows based machine lang

컴파일러는 실행파일과 OS구성을 결합함

Java Source > Java Compiler > bytecode(가상기계어) > Win/Linux/macOS Bytecode executor(Java Virtual Machine) > win/linux/mac (doesnt matter bout OS)
->CPU run

가상기계어(IR) execute > engine = VM = Runtime

LLVM(LowLevelVirtualMachine) IR(intermediate representation)

source execute > interpreter , player , engine ( ex- asp php j script)


programs that executed by machine language - exe com (bat is not)

.php > php engine >can be execute on windows
.js > JavaScript engine(=V8) > =

(JAVA)SOURCECODE ((JAVA)COMPILER) >IR = Bytecode (RUN)> VM(=Interpreter/engine/player/viewer) > (RUS)OS

IR은 VM을거쳐 OS에서 실행되기 전 VM에서 다시 Compile을 거치며 Temp와같은 임시저장소에 저장후 OS로 전송됨(속도향상 도모)

unix =/ linux (compile 요구, 높은 호환성)

OS(android포함)-JIT Compiler내장
JIT-설치시 AOT대비 설치속도가 빠름,실행시 번역중 딜레이있음
Ahead Of Time-AOT방식 컴파일러(프로그램의 설치시점에 compile-기계어변환함/추후 실행의경우 기존보다 빠른 실행속도)
JIT+AOT - 설치후 essential compile 대기시간 나머지 Compile

vm-가상머신실행/IR을 읽을경우
engine-일반실행/(js등의)sourcecode읽을경우


java code (JavaCompiler 번역/문법오류검사) -> IR(기계어검사) -> vm -> OS / 실행시간 짧음
js(source/Interpreted language-컴파일러를 거쳐서 기계어로 변환되지 않는 언어) -> 실행시 문법검사를 거침+실행시 해석필요/실행시간 길어짐

JIT / AOT는 이를 해결하기위하여 개발된 방식

.classfile=bytecode file

javap(profile)
javac(compile)

compilefirst> java .class





.js(javascript) (javascript/engine/(interpreter))> node.exe > os
c 와같이 linker를 이용한 라이브러리/script 통합을 하지않음. 
simillar .py .php .pl

java는 가상기계어를 채용 JVM을 이용하여 VM에서 실행. java는 compile/interpreter 결합방식 채용
java(javacompiler)>Bytecode(P-code/IR)(ex-.class) >JVM(java.exe)
.c>.obj>.exe

CLI > Command Line Interface(terminal/Powershell)


file sort rule
src
  branch main folder
    branch java < java sourcefile ex).java
    branch resources < 실행시 이용되는 기타 파일.properties,txt,xml~
    branch webapp
  branch test
    branch java < unit test 실시하는 java sourcefile ex).java
    branch resources < unit test 등에 사용하는 기타파일


bitcamp-study
  branch bitcamp-docs
  branch bcjava
    branch src/bin
  branch bitcamp-java-project
    branch src
    branch bm



empty folder will not upload on github_storage



javac -d bin/main 
java -cp

패키지에 소속하는 sourcefile은 컴파일시 주소가 명기된 폴더에 생성됨
com 폴더는 패키지폴더로 정의됨

//java-kotlin같은 java 호환언어는 다른 source여도 컴파일시 동일결과를 산출 따라서 언어의 차이에따라 패키지폴더가 구분될 수 없어 충돌이일어남 > main() java폴더가 생성되지 않음

java -cp : class path 명령어, package경로가 선언된 파일의 경우 package folder를 지정함 이로 인하여 하위폴더의 java(class)를 구분할 수 있음// 확인필요

package 소속 .class 실행시 경로는 .com 이전까지의 폴더만 표기후 공란요구
example  java -cp bin/main .com/ohoracs/basic/Hello3


cpu 논리회로의 작용방식 체크*

PS C:\Users\user\git\bitcamp-study\bitcamp-java> javac -d bin/main src/main/java/Hello5.java
PS C:\Users\user\git\bitcamp-study\bitcamp-java> java -cp bin/main Hello5
*package example


web dev
요구사항 식별 > 분석 > 설계
//빌드(빌드도구 예시 Ant -> Maven > Gradle)\/*
프로젝트폴더 준비
웹에 필요한 파일 .java (compile > .class).xml .html .css .js
unit test(ex-junit)
as result > .jar .zip .war(배치파일) + API(해당 app을 응용하는 개발자를위한)문서생성
>> (업로드) 서버배치() */

eclipse는 설정파일 없이는 프로젝트폴더 인식불가


<name></name><tag></tag>(element,metadata)

복잡한 제어를 할 수 있는기능>XML

groovy 언어를사용해 설정파일(스크립트) 적용
build.gradle < gradle을 설정도구로 사용했다는 설정파일

.c compile결과는 변환후 기계어(CPU instruction).exe 파일로 생성됨. 구문은 링커를통하여 라이브러리를 사용, .exe생성. 따라서 실행이 빠름,기계어로의 compile시 플랫폼에 종속됨(cpu/os) // compile 방식
.js의 경우 nodejs에서 실행할 부분만 검사시행후 실행, 오류있어도 해당구문 실행이 없으면 에러없음,배포시 오류존재가능. source를 읽어 실행하므로 속도가 느림, compile이없어 코드변환이 편리 // interpreter 방식
.java의 경우 JavaCompiler을 통해서 IR인 .class로의 변환 이후에도 JVM을 이용해야 실행가능/ 실행속도 C보다 느림> 보완을위해 JIT/AOT 컴파일러방식 등장
 / 인터프리터,컴파일러 결합방식

DSL - 특정 영역에서 사용할 언어(build.gradle 설정파일에 사용할 언어)

tree /a /f *커맨드라인 명령어

//.js / javascript는 

class-분류명, function을 목적에따라 분류하는 문법- 모든 function은 class에 소속해야함
java-언어의 관리/유지보수를 목적으로하는 객체지향언어, function의 그룹분류를 쉽게하기 위함
java,c++,python...(객체지향프로그램 oop)


@Override annotation > 기존에 있는 기능을 임의로 재정의함
toString - 객체 정보값을 문자열로 만들어 리턴하는 메소드


(blcok단위도 마찬가지로 생각할 수 있음)1byte=8bit // 2^(bit)수 만큼 


Application software 구조 - 기능단위로 묶인, 명령어가 들어있는 function의 집합을 역할에 따라 관리하기 쉽게 묶는문법인 class로 치환>단일 .java파일 내부에 하나이상의 class를 묶음
class의 관리를 위하여 package 도입(관리를위하여 디렉토리로 묶음) > .java는 package에 소속될수없음, .class는 해당 상위 .java파일의 첫줄에 선언한 package의 경로에 따라 생성관리됨
.java를 컴파일시 각각의 class는 .class파일로 변환됨
package로 .class를 관리시 .com.a.b 의경우 b에 미리 .class를 생성했어도 a 상위폴더에 package를 지정가능하여 /b/.class지정이 가능

SystemIntegretion - 신규프로젝트 - 기능추가
SystemMaintenence - 완료된프로젝트 - 기능추가및변경


//ObjectOrientedProgramming commandline map
Data 저장 - file Input/Output - 개발자가 직접 Data를 저장하는 도구(JDBC : DBMS를 사용하여 Data를 저장시키는 도구)사용법
MybatisFramework - JDBC를 쉽게 사용하게 해주는 도구 사용법
Data transfer > socket networking
Data -> web에서 결과송출 수단으로 HTML/CSS 선택
     서버관리 spring webMVC
     -> 최종사용자의 행동제어 .js (javascript) 선택
     bootstrap/jQuery 사용
     Data 구조화 알고리즘 - LinkedList / stack / Queue

literal - data표현
변수variable - data를 저장할 메모리 준비(선언) + array - 같은 유형의 메모리를 여러 개 준비시키는 문법
연산자 - data를 가공하는 도구
제어문(조건,반복문등) - 명령문의 실행흐름 제어
method(function) - 명령어를 관리하기 편하게 기능단위로 묶은 문법
class - method를 관리하기편하게 역할(Role=responsibility)단위로 분류시키는 문법 
 ㄴ상속 - 기존 명령 extend,새 기능 추가/변경
  //하위 3개문항을 다형성이라고 칭함
  ㄴ다형적변수 - 개념추상화, 같은 유형의 메모리를 지정하는 방법
  ㄴOverriding - 기존 method 재정의  // 기존 class에서 개발자가 정의한 변수의 재정의
   ㄴOverloading - 같은 이름의 유사기능 추가문법
 ㄴ 사용자 정의 데이터타입 - 메모리구조를 data에 맞게 커스터마이징 하는 문법 // ex('int=x' 선언시 정의되는 int)
  ㄴ접근제어(캡슐화) - method / memory의 접근을 제어
  ㄴinstance -
   ㄴ instance method - 인스턴스 메모리를 다루는 기능
  ㄴ생성자 - 인스턴스를 초기화시키는 기능
  DesignPattern - 효율적인 클래스 구조관리


CPU Instruction 에서 문자열과 정/난수등의 구분 > 문자열은 code로 저장
CharacterSetCode > 문자열을 저장하는 코드 ex)ASCII ISO-8859-1
부동소수점의 경우 정규화규칙을 정하여(IECC 754) 2진법으로 전기적신호로 변환함

2진수로 변환이 가능한것은 전기적신호로 변환할 수 있음(빛의경우 RGB, 0~255사용/참고 http://m.insightsemicon.com/m/m_article.html?no=128795)

jpg 용량 > 압축을통하기에 BMP보다 용량이작음
encoding > 2진수로 코드화를시킴 

정수값의 저장 > 문서에서 전기적 신호를 표기하는 방법인 2진수로 표현(Encoding/변환) > 실제 CPU Instruction인 전기적신호로 메모리에 저장
문자열의 저장 > CharacterSetCode(ISO-8859-1/문자를 8bit로 변환)의 규격으로 변환 > cpu instruction전기신호로 메모리에 저장
*java에서는 문자열을 내부규격으로 변환 (ex UCS-2/16bit)
논리 : true > 00000001 >CPU I
색상(pixel shows) : yellow > 11111111(R) 11111111(G) 00000000(B) 매 연산마다 3byte사용 > CPU Instruction전기신호로 변환

encoding : 값을 규칙에의하여 값'(진수값)으로 변환하는것
decoding : 값'을 복원하는것

데이터인코딩 ex)mpeg/H.264->  > 압축데이터(jpeg등) // 압축시 파일손상이 발생하여 해상도 및 품질이 하락 
복원(decoding) 시 Codec 요구

정수값을 2진수로 변환시 무조건적으로 2의보수 사용
부동소수점의경우 가수부(Magnitude방식으로 2진수로 변환)/지수부(K-excess방식으로 2진수로 변환) 로 표기/나눔
ㄴ Magnitude 방식으로서 음수양수를 같은값으로 치환, 부호를 첫 비트로 표현
ㄴ K-excess 방식으로 127bit 초과
문자>2진수로 변환시 UCS-2 CharacterSet을 준거하여 2진수로 변환
논리 > true : 1 / false : 0

HDD는 자석가루를 이용하여 데이터를 기록함, 따라서 전원공급이 사라져도 데이터가 유지가능.
RAM은 휘발성 메모리이기에 전원공급이 끊어지면 데이터가 소멸함.
SDD는 내장 배터리가 있으므로 데이터가 유지가능.
windows 저장장치HDD는 platter의 관리를 위하여 platter의 저장공간을 track으로 칭함. 한번 arm이 데이터를 읽을경우 사용하는 track의 묶음을 cylinder라 칭한다.
track을 사용하여 데이터를 할당함. track은 sector로 분류 각각의 섹터에 512bytes를 저장, 해당 sector가 할당시 할당공간의 일부만을 사용할 수 없음,따라서 1byte를 저장하더라도 4096byte를 사용.
이 sector의 체계(format)을 관리/준비하는 시스템을 file system 으로 칭함 ex)NTFS/FAT32/Ext2,3
hdd의경우 sector가 불량이 생길경우 해당 sector만 badsector로 정리하고 사용을안함/SDD의경우 칩이기에 회선이 하나 고장날경우 사용이불가능
따라서 OS가 다를경우에 usb을 이용하여 파일을 옮기기위해선 usb포멧이 필요함
자석 기록방식이 수평기록방식 > 수직기록방식으로 개선되어 저장장치의 용량이 늘어남
flashmemory는 배터리가 존재하기에 기록저장기간이 6개월~2년후에 급속도로 줄어듦, 따라서 교체가 필요함


literal - 8진수 - 0~ / 2진수 - 0b~ / 16진수 - 0x~

literal - 4byte/8byte로만 나뉨 10진수-4byte
@bit가 표현가능한 값 = 2^@-1(0부터 값을 체크함) (5bit // ex - (2^5-1))

literal 1byte = 8bit, 2^31(4bytex8bit)
literal 1byte = 8bit, 2^31 = 'L'ong

sign magnitude - 맨 앞 bit만 1로 변환하는것으로 음수 표시 > 이 방식은 calc실행시 결과값이 비정상
1's complement(1의 보수 = 1이 되기위하여 보충하는 수) 방식 채용 > 모든 비트를 1이 되는 수로 바꾼다 > 진수표기에서 0을 1, 1을 0으로 변환
 > 32bit를 초과하는 1은 버려짐 > 음수를 더할 경우 결과값에 1을 추가해야함(번거로움/단점) 

1의 보수 + 1 = 2의 보수

2's complement(2의 보수//현대 language,computer에서는 모두 채용) > 음수를 저장할때 미리 1을 추가해둠 > 1의보수의 음수값 더할시 계산결과에 1을 추가하는 방식을 개선
>음수를 메모리에 저장시 정상적인 값 산출을 위하여 2의 보수방식으로 음수를 저장



//- 2의 보수를 만드는 방법 1:
//  - 모든 비트를 반대 값으로 만든 다음 1을 더한다.
//  예) 0010 1001(+41)
//      1101 0110(1의 보수)
//              1
//      ---------
//      1101 0111(-41)
//- 2의 보수를 만드는 방법 2:
//  - 오른쪽에서부터 1을 찾는다.
//  - 찾은 1의 왼쪽편에 있는 모든 비트를 반대 값으로 바꾼다.
//    예) 0010 1001(41) => 1101 0111(-41)
//                ^                ^
//    예) 0010 1100(44) => 1101 0100(-44)
//              ^                ^
//- 2의 보수를 만드는 방법 3:
//  - 2^n(8비트일 경우 2^8 = 256)에서 음수 값 만큼 뺀다.
//    예) -41 => 256 - 41 = 215 = 1101 0111
//    예) -44 => 256 - 44 = 212 = 1101 0100
//- 수의 범위(8비트 기준): -128 ~ +127

//4) K-초과(Excess-K)
//- 부동 소수점의 지수부(exponent)를 저장할 때 사용한다.
//- 오프셋 바이너리(offset binary) 또는 바이어스된 표기법(biased representation) 이라고도 한다.
//- K를 바이어스 값이라 부르며, 표현하려는 값에 더할 때 사용한다.
//    표현하려는 값 + 초과 값(K) = 결과
//- 바이어스 값(K)을 구하는 공식:
//    K = 2^(비트수 - 1)
//  예) 8비트일 경우 ---> K = 2^(8 - 1) = 2^7 = 128, 결과 = 128 + 값
//   1111 1111 = 128 + 127
//   1111 1110 = 128 + 126
//   1111 1101 = 128 + 125
//      ...
//   1000 0001 = 128 + 1
//   1000 0000 = 128 + 0
//   0111 1111 = 128 + (-1)
//      ...
//   0000 0010 = 128 + (-126)
//   0000 0001 = 128 + (-127)
//   0000 0000 = 128 + (-128)
//
//- IEEE 부동소수점 표준에서는 다음의 공식을 사용한다.
//    K = 2^(비트수 - 1) - 1
//  예) 8비트일 경우 ---> K = 2^7 - 1 = 127, 결과 = 127 + 값
//   1111 1111 = 127 + 128
//   1111 1110 = 127 + 127
//   1111 1101 = 127 + 126
//   1111 1100 = 127 + 125
//      ...
//   1000 0000 = 127 + 1
//   0111 1111 = 127 + 0
//   0111 1110 = 127 + (-1)
//      ...
//   0000 0010 = 127 + (-125)
//   0000 0001 = 127 + (-126)
//   0000 0000 = 127 + (-127)
//
//- 바이어스 방식으로 데이터를 저장할 때의 이점?
//  - 모든 비트가 0일 때 최소 값을 가지고, 모든 비트가 1일 때 최대 값을 갖는다.
//  - 이런 이유로 작은 값에서 큰 값으로 정렬되는 결과를 낳는다.
//  - 모든 비트가 정렬된 상태이기 때문에 부동소수점이든 정수이든 상관없이 값을 비교할 때 속도가 빠르다.
//  - '부호-크기', '1의 보수', '2의 보수'와 같은 방법으로 값을 표현할 경우, 비트들이 순차적으로 정렬되지 않는다.
//




보수방식을 채용하기에 cpu에는 -(minus)연산을 위한 장치가 존재하지않음

부동소수점 - 8byte가 기본 저장방식



2^7 = 128 영어 대소문 / 숫자 / 특수문자 등 90여개 문자에 대해 code value 정의 -> ISO-8859-1(ISO LATIN I = ASCII+western language/8bit->256문자 정의가능)
iso) A -> 01000001 B-> 01000010 C -> 01000011
실질적으로 사용하는 숫자 = 200여개 > 
>EUC-KR의 등장(16bit,=<windows 3.x ) english ->ISO-8859-1(8bit 그대로 사용) > 한글> 2byte code value로 정의 ex) 가 > 0xB0A1 / 각 > 0xB0A2 ... 각 문자별 정의
조합형 한글코드의 등장 > (KSC 5601) 128~159에 문자 코드를 사용하여 국제표준을 위반함. 이로인하여 .hwp에서만 기용됨
국가의 문서가 특정 기업에 종속되는것을 피하기 위하여 open document가 구현됨. 이는 xml을 이용함 / MS측도 코드소스를 공개하여 docx/pptx/xlsx포멧 공개(xml이용)
ECMA에 제출 후 국제표준으로 인정받음
MS949의 등장(11172자/windows95 +) 국제 표준X
CharSet 은 문자에대한 코드값을 정의한 표를 의미
UTF-8은 
JAVA 는 source를 내부적으로 다룰때는 unicode를 사용, 외부에 export / 통신을 할 경우 UTF-8을 사용함
JVM의 경우 내부적으로 UCS-2를 사용함
JVM(ucs-2) > file/Network(utf-8) / 반대의경우는 변환을 필요 // export시 encoding이 utf-8이라면 javac 사용시 unicode set을 할 필요성이있는가

UTF-8의 사용예시 - search engine에서 한글을 검색할 경우 %BA%..등의 코드를 접할 수 있음. 이는 UTF-8로의 인코딩을 했다는 기록
letter A > 0041(UCS-2 CharacterSet,encoding) > Transfer to website 41(encoding) > A(URL Encoding)
letter 가 > AC00 > EAB080(encoding) > %EA%B0%80(URL Encoding)
                   EAB080(decoding) <

Value를 polices/rules에 따라 Value를 가공하는것 > Encoding
가공된 Value를 rules에 따라 복구하는것 > Decoding
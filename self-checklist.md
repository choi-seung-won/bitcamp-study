# 컴퓨터와 소프트웨어		
[o]컴퓨터와 소프트웨어의 관계를 이해한다.	

A 소프트웨어는 저장된 저장소에서 명령을 cpu에 송출하여 cpu의 연산결과값을 표기하게 한다

	
[o]시스템 소프트웨어와 응용 소프트웨어를 구분할 수 있다.		

A 드라이버, OS등을 필두로 한 시스템 소프트웨어는 하드웨어에 직접적으로 관련된, low level / static 코딩을 전제로 한 소프트웨어
	응용 소프트웨어는 하드웨어의 구동에 관여하지 않는 OS에 탑재되어 구동하는 기능성 소프트웨어이다


# 프로그램의 구동 원리		
[o]컴퓨터에서 프로그램이 실행되는 원리를 이해한다.

A 소프트웨어의 실행은 저장장치에 저장된 작성 완료된 명령어(CPU Instruction) 인풋을 RAM에 Loading후 CPU에 인계해 연산을 실행시킴
그 이후 연산된 결과는 RAM에 다시 전송됨.

		
[O]CPU 인스트럭션이 무엇인지 이해한다. (ARM CPU 기준)	검색	http://vision.gel.ulaval.ca/~jflalonde/cours/1001/h17/docs/arm-instructionset.pdf

/* ARM에서는 모든 CPU명령은 모든 명령문실행은 현재 상태 레지스터와 상태 레지스터 플래그에 의거하여 실행된다, C,N,Z,V 플래그가 설정된 필드의 조건을 만족할경우 명령문은 실행되고 그렇지 않을경우 무시된다.
명령문 실행은 branch에서 general register에서 전송된 명령문을 복사하여 Program counter에 전송해 다음으로 실행 될 명령어의 주소를 가져 그것을 실행할 기계어 코드의 위치를 지정한다
이는 CPU가 모든 시간동안 여러 명령구문을 각각 다른 클럭에서 실행 가능하게 한다 */

CPU Instruction이란 CPU가 인식가능한 기계어로 연산을 요청하는 프로세스를 의미한다
CPU Instruction = 기계어


[O]CPU 인스트럭션과 실행 파일, OS의 관계를 이해한다.

A 저장장치에서 실행된 명령구문은 OS의 명령문 실행 요청에 따라 CPU에서 연산 및 처리됨

		
[o]같은 CPU에 맞춰 작성된 실행 파일이더라도 OS가 다르면 실행되지 않는 이유를 설명할 수 있다.		

A CPU는 동일한 기계어를 사용하나 각각의 OS는 요구하는 규격이 다르므로 실행될 수 없다

# 중간 언어와 가상 머신		
[O]중간 언어와 가상 머신이 등장한 이유와 이점을 설명할 수 있다.	

A Compiler는 각각 한 종류의 OS에만 대응하므로 OS에 따라서 다른 Compiler의 사용이 강제되는것이 불편하다 느껴 Java가 개발되었다. Java Compiler는 가상 기계어인 Bytecode로 언어를 변환하여 Win/Linux/macOS와 같은 OS에 모두 대응이 가능하다.
	
[O]VM과 인터프리터, 런타임, 플레이어, 엔진의 역할을 이해한다.

A 엔진,플레이어,런타임,VM은 동일하게 Intermediate representation의 실행기로서 작용한다.
//런타임은 특수한 기능을 배제하고 온전히 프로그램의 실행만을 위한 환경이다.
//VM은 샌드박스 실행환경을 조성해준다. 따라서 JVM같은경우는 OS의 구분없이 실행이 가능하다.



[o]JIT(Just-in-time)과 AOT(ahead-of-time)이 무엇이고 등장한 이유를 이해한다.		

JIT는 설치시 AOT대비 설치속도가 빠름, 실행시마다 컴파일을 거치기에 실행시 간헐적인 딜레이가 생김
JIT의 문제점을 해결하고자 AOT가 등장. AOT는 설치시 기계어 컴파일을 포함하기에 설치 속도는 느리나 실행후 간헐적 딜레이가 없음

# 자바 바이트코드와 자바 가상 머신		
[o]자바 바이트코드 실행 환경을 준비할 수 있다.		OpenJDK 설치, JAVA_HOME 과 PATH 환경 변수 설정, Sublime 편집기 설치

A system enviroment-JAVA_HOME에서 JAVA의 \bin폴더를 입력함으로서 어느 디렉토리에서나 JAVA를 사용할 수 있다.
PATH 환경변수를 입력함으로서 JAVA가 아닌 컨텐츠 또한 어느 디렉토리에서나 이용할 수 있다.


[O]자바 바이트코드를 이해한다.	검색	https://docs.oracle.com/javase/specs/jvms/se13/jvms13.pdf

A JAVA ByteCode란 모든 종류의 OS에서 JAVA의 개별 컴파일러를 실행할 필요 없이 JavaCompiler로 컴파일하여 JVM에서 바로 실행 가능한 IR을 지칭한다


[O]바이트코드와 클래스 파일(.class)의 관계를 이해한다.	/HelloWorld.class	https://medium.com/@davethomas_9528/writing-hello-world-in-java-byte-code-34f75428e0ad

.Class(가상기계어) JVM에서 실행 가능한 Bytecode()

[o]클래스 파일과 JVM의 관계를 이해한다.		$ javap HelloWorld.class, $ javap -verbose HelloWorld.class

JVM=ByteCode-IR을 실행하는 실행기

[o]JVM을 이용하여 클래스 파일을 실행할 수 있다.		$ java HelloWorld

CLI에서 javafile 대상으로 한 javac 커맨드를 이용하여 class파일을 생성

# 프로그래밍 언어와 컴파일		
[O]컴파일 방식 프로그래밍이 등장한 이유를 이해한다.		

A 매 시퀀스마다 VM에서 번역하는 과정을 없애 속도향상을 도모하기위하여 도입되었다.


[O]프로그래밍 언어와 컴파일, CPU 인스트럭션의 관계를 이해한다.	

A 프로그래밍 언어는 각각의 OS에 대응되는 컴파일러를 통해서 IR 혹은 ByteCode 로 변환된다, 이는  CPU에 전송되어 

[O]컴파일러를 이용하여 소스 코드를 목적 코드(CPU 인스트럭션)로 생성하는 과정을 이해한다. (C 프로그래밍 언어 기준)	/module.c, /main.c	$ gcc -c 소스파일

A 작성완료된 .C 파일은 컴파일러를 통하여 링커의 라이브러리와 함께 같은 파일로 묶이게된다, 이 결과로 .exe파일이 산출된다.

[O]링커를 이용하여 목적 코드가 들어 있는 파일을 하나로 묶어 실행 파일을 만드는 과정을 이해한다. (C 프로그래밍 언어 기준)		$ ld -o 실행파일 목적파일 목적파일 … -lSystem -macosx_version_min 10.13

A .C언어의 컴파일은 링커의 관여에 따라서 라이브러리와 같은 파일로 묶이게된다

[O]"소스 파일, 목적파일, 실행 파일"과 "컴파일러, 링커"의 관계를 이해한다. (C 프로그래밍 언어 기준)		

A sourcefile은 컴파일러에의하여 목적파일로 compile되고 이는 링커가 작용함에 따라서 실행파일로 컴파일된다.


# 컴파일러와 인터프리터		
[O]인터프리트 방식 프로그래밍과 실행 과정을 이해한다.

A .js와 같은 인터프리트 방식 프로그래밍은 실행되는 구문만을 컴파일한다,/* linker와 관련될수 없으므로 외부 라이브러리가 필요하지 않다.*/

[O]Node.js 자바스크립트 인터프리터를 준비할 수 있다.		https://nodejs.org/en/

A scoop 이용

[O]인터프리터를 사용하여 소스 파일을 직접 실행하는 과정을 이해한다. (Node.js 기준)	/hello.js	$ node hello.js

A 소스파일중 실행될 구문만이 매 실행마다 검사된다. 속도는 떨어지며 버그리포트가 힘들어지지만 이로인하여 쉬운 유지보수가 가능하게된다.

[O]컴파일 방식과 인터프리트 방식의 구동 원리를 이해한다.		

A 컴파일방식은 전체 프로그램을 컴파일하며 인터프리트 방식은 매 실행시마다 구동에 필요한 코드만 검사 후 실행한다

[O]컴파일 방식과 인터프리트 방식의 장단점을 비교할 수 있다.		

A 컴파일방식은 버그리포트가 쉽고 첫 실행후엔 실행속도가 빠르지만 인터프리트 방식보다는 유지보수가 힘들다
	인터프리트방식은 OS에 구분없이 node(engine)만있다면 사용할 수 있다.


# 자바 프로그래밍 절차		
[O]자바의 프로그래밍 방식과 실행 원리를 이해한다.		

A JAVA는 .c와 달리, 모든 method/class를 각각의 하위문서로 분류한다.

[O]자바 코드와 바이트코드, 소스 파일과 클래스 파일의 관계를 이해한다.		

A java source는 컴파일러를 거쳐 Bytecode(classfile)로 변환되고 이는 JVM을 거쳐 실행된다.

[O]자바 컴파일러와 JVM의 역할을 이해한다.		

A Java compiler 의 IR을 JVM은 OS의 구분없이 일괄적으로 실행할 수 있게 한다

[O]CLI 환경에서 컴파일을 수행할 수 있다.	/Hello.java	$ javac Hello.java

A command line interface 

[O]CLI 환경에서 자바 클래스 파일을 실행할 수 있다.	/Hello.java	$ java  Hello

A .java > javac > .class > java > result

# 소스 파일과 컴파일 결과 파일 분리 		
[O]Maven 표준 디렉토리 구조를 만들 수 있다.		Maven 표준 디렉토리 구조에 맞춰 폴더를 생성

A bin / src - main / java

[O]각 디렉토리의 용도를 이해한다.		

A binariy = .class파일 저장소 src = .java sourcefile 저장소

[O]프로젝트 디렉토리에서 소스 디렉토리에 있는 자바 소스 파일을 컴파일 할 수 있다.	src/main/java/Hello2.java	$ javac src/main/java/Hello2.java
[O]컴파일 할 때 컴파일 결과로 생성된 클래스 파일을 별도 디렉토리에 분리할 수 있다.	src/main/java/Hello2.java	$ javac -d bin/main src/main/java/Hello2.java
[O]다른 디렉토리에 있는 클래스 파일을 실행할 수 있다.	src/main/java/Hello2.java	$ java -classpath bin/main Hello2

# 패키지와 소스 파일		
[O]패키지의 용도를 이해하고 패키지를 생성할 수 있다.	com.ohoracs.basic	src/main/java/com/ohoracs/basic 디렉토리 생성

A javac -d 커맨드 사용시 정의할 폴더생성

[O]소스 파일에 작성한 코드가 패키지에 소속되게 할 수 있다.	src/main/java/com/ohoracs/basic/Hello3.java	

A package .com.~.~

[O]패키지에 소속된 소스 파일의 적절한 디렉토리 경로와 왜 그 위치에 놓아야 하는지 이해한다.		

A 유지보수목적

[O]컴파일 한 후 생성된 클래스 파일의 디렉토리 경로와 그 위치에 있어야 하는 이유를 안다.		

A 패키지의 상위폴더에 위치할 경우 발생하는 파일 중복등의 경우를 방지하기 위함/유지보수목적

[O]패키지에 소속된 클래스 파일을 실행할 수 있다.	src/main/java/com/ohoracs/basic/Hello3.java	$ java -cp bin/main com.ohoracs.basic.Hello3

A javac 로 .java를 bin/ 폴더의 .class로 변환후 java 커맨드로 .class 를 실행

[O]패키지를 적용하지 않은 채로 그 소스 파일을 그냥 패키지 폴더에 둔다면 컴파일 할 때 어떤 문제가 발생하는지 안다.	src/main/java/com/ohoracs/basic/Hello4.java	

A 컴파일시 .class 파일이 경로를 따르지않고 패키지폴더 최상위에 생성된다

# Gradle 빌드 도구		
[O]Gradle 빌드 도구를 이용하여 작업 폴더를 자바 프로젝트 폴더로 구성할 수 있다.	/프로젝트폴더	$ gradle init

[O]Gradle로 생성된 src 디렉토리의 구조를 이해하고 설명할 수 있다.	/src	

A 원본 sourcefile 이 저장되는 곳

[O]src 디렉토리 외에 다른 디렉토리나 파일의 용도를 이해한다.		


A distribution에 실행 가능한 bat파일과 ok파일이 생성되며 libs에는 실행에 필요한 라이브러리가 저장됨, 또한 test폴더에는 테스트용 파일이 생성됨.

## 자바 기초 문법 - com.ohoracs.basic

#### 클래스 블록과 컴파일, 실행

- [O] 소스 파일(.java)과 클래스 블록(class 클래스명 {…}), 클래스 파일(.class) 관계를 이해한다. `ex01/Exam11.java`

A .java 소스파일은 컴파일을 통하여 각각의 클래스 블록마다 하나의, package의 하위 .class파일로 분리된다

- [O] 한 소스 파일에 여러 개의 클래스 블록이 있을 때 컴파일하면 어떻게 되는지 안다. `ex01/Exam12.java`

A .java파일의 클래스 블록의 갯수에 따라서 bin/ 하위폴더의 경로 혹은 패키지폴더에 분류된 클래스 블록의 갯수만큼 .class 클래스파일이 생성된다 

- [O] 클래스의 사용 범위(공개/비공개)에 따라 소스 파일과 클래스 블록의 이름이 어떤 관계가 있는지 안다. `ex01/Exam21.java, Exam22.java, Exam23.java`

A public class는 소스파일의 최상위 클래스에서 반드시 정의되어야 하며 이 class블록의 네임은 소스파일과 동일해야한다 

- [O] 컴파일 할 때 소스 파일의 인코딩을 지정할 수 있다. `ex01/Exam3.java`

A charset 지정을 위해 컴파일시 -encoding UTF8 명령어를 사용한다. UTF8이 일반규격이기에 UTF8로 선언하는것이 선호된다.

- [O] JVM이 클래스를 실행하는 과정을 이해하고 설명할 수 있다.

A JVM은 가상머신에서 클래스블록과 해당 블록아래의 펑션을 포함한 .class를 실행한다.  // ?

- [O] main() 메서드의 용도를 알고 있으며 작성할 수 있다. `ex01/Exam4.java`

A main() method는 .class가 실행되기 위한 최소구조이다.


#### 주석

- [O] 자바 소스 코드에 주석을 달 수 있다. `ex02/Exam1.java`

A // /**/

- [O] 주석(`//, /* … */`)의 종류와 작성법을 안다. `ex02/Exam1.java`

A //
/*
*/
/* A */

- [O] Javadoc 주석(`/** … */`)의 용도를 이해하고 이 주석을 이용하여 HTML 문서를 생성(`javadoc 사용`)할 수 있다. `ex02/Exam2.java`

A javadoc -encoding UTF-8 -charset UTF-8 -d javadoc -sourcepath src/main/java com.ohoracs.basic.ex02
javadoc folder 하위폴더에 생성됨.

- [O] 애노테이션(`@Override`)의 용도와 문법을 이해한다. `ex02/Exam3.java`

A @Override는 기존에 개발자에 의하여 정의된 .class 변수의 재정의한다는것을 알리는 것

#### 데이터 종류에 따른 리터럴 표기법

- [O] `정수, 부동소수점, 논리, 문자, 문자열` 리터럴 문법의 용도를 이해한다. `ex03/Exam1.java`

A 상수에 넣는 불변의 데이터를 리터럴이라 칭한다. 인스턴스 클래스에는 적용할 수 없으며 생성후 객체 내 데이터가 변하지 않는 불변 클래스에서 사용할 수 있다.

- [O] 정수 리터럴을 10진수, 8진수, 2진수, 16진수로 표현할 수 있다. `ex03/Exam21.java`

A 0x, 0d, 4e

- [O] 문자 '_' 를 사용하여 정수 리터럴의 자릿수를 표현할 수 있고, _ 문자의 적절한 위치를 안다. `ex03/Exam22.java`

A     System.out.println(0b110_0100);
    System.out.println(0b1_1_0_0_1_0_0);

- [O] 메모리에 값을 저장하기 위해 데이터를 2진수로 변환해야 하는 이유를 설명할 수 있다.

A CPU Instruction은 2진수값으로 문자열/truefalse/수 를 표현함

- [O] 메모리 크기에 따라 정수를 저장할 수 있는 범위가 다른 이유를 이해한다.

A RAM에 저장가능한 최소값인 bit, (byte)memory 크기에 따라서 송출가능한 bit값이 다르기에 정수값을 저장 가능한 범위도 비례하여 바뀐다.

- [O] 메모리 크기에 따라 정수 리터럴을 4바이트와 8바이트로 구분하여 표현할 수 있다. `ex03/Exam23.java`\

A 4 - Integer, 8- Long

- [O] 정수 리터럴이 메모리 크기를 벗어날 때 어떤 문제가 발생하는지 안다. `ex03/Exam23.java`

A 메모리 크기를 초과할 시 컴파일 오류가 발생함.

- [O] 정수 리터럴이 메모리에 어떻게 저장되는지 이해한다. `ex03/Exam24.java`

A CPU Instruction 과 동일한전기신호로 저장됨

- [O] 정수를 2진수로 표현하는 다양한 방법을 이해한다. (Sign-magnitude, 1의 보수, 2의 보수, Excess-K 방식)

A C:\Users\user\git\bitcamp-study\개발준비.txt 385~

- [O] 부동소수점 리터럴을 다양한 방식으로 표기할 수 있다. `ex03/Exam31.java`

A E(10^x)x등의 방식을 채용가능 


- [O] 메모리 크기에 따라 부동소수점 리터럴을 4바이트와 8바이트로 구분하여 표현할 수 있다.`ex03/Exam32.java

A 8-d/D 4-f/F



- [O] 메모리 크기에 따라 부동소수점의 최소/최대 크기를 알아낼 수 있다. `ex03/Exam33.java`

A 4/8을 Float/Double 에 대응하여 Float.MAX/MIN_Value 를 출력

- [O] 부동소수점이 메모리에 저장되는 원리를 이해한다. (IEEE 754 규칙에 따라 부동소수점이 2진수로 변환되는 것을 이해한다.) `ex03/Exam34.java`

A excess - K/ 정규화를 통하여 가수부와 진수부를 분리한다, 23번 비트까지는 가수부가, 31번 비트까지는 진수부가, 32번비트는 음수일경우 1, 아닐경우 0을 위치시킨다

- [O] 부동소수점이 때론 완전하게 2진수로 변환되지 못하는 이유를 안다.

A *소수점 아래값에 *2를 번복하며 1값을 올리는 방식으로 변환을하는데 개중에선 *2^i가 0이 될 수 없는 숫자가 존재하기 때문


- [O] 자바에서 부동소수점을 IEEE 754 규칙에 따라 2진수로 변환된 것을 확인해 볼 수 있다. `ex03/Exam35.java`

A 2진수값으로 변경된 부동소수점을 .class파일을 열어서 확인할 수 있다, - 에디터의경우 2진수를 16진수로 바꾸어 출력하므로 12.375의 16진수값은 0x4146 0000이 된다

- [O] 문자 리터럴을 다양한 방식으로 표기할 수 있다. `ex03/Exam41.java`

A '' 를 사용하여 문자를 표기할 수 있다(문자열과 구분됨), 유니코드에 대응하는 문자코드를 알고있다면 \uCHAR 로 출력할 수있다. \u뒤에 나오는 모든 값은
문자로서 출력된다

- [O] 문자 집합(character set), 유니코드, UCS, UTF, UTF-8, UTF-16의 의미를 이해한다. `ex03/Exam42.java`

A 각 Charset은 각 문자가 차지하는 byte의수가 재각기 다르기에 hex값으로 볼 경우 값이 다른문자가 많아 charset이 다를경우 hex값이 지정하는 fontfile이 존재하지 않아 문자가 깨짐, UTF8,UTF,UCS는 유니코드를 사용하기 위한 인코딩규칙

- [O] ASCII, ISO-8859-1, EUC-KR, 조합형, MS949, Unicode의 의미를 이해한다.

A 각각 다른 Charset

- [O] UCS(ISO 10646)를 UTF-8로 바꾸는 규칙을 이해한다.

A UCS의 코드 중 127까지의, ASCII코드는 그대로 사용하고 이외는 해당 규격에 맞게 변경

- [O] UCS 대신 UTF-8이 사용되는 이유를 안다.

A 기존 ASCII로 코딩된 문서도 UTF-8로 읽을 수 있고, 영어의경우 1바이트로 표기가 되므로 리소스의 낭비를 피하기 위함.

- [O] 문자를 다룰 때 작은 따옴표('')의 의미를 이해한다. `ex03/Exam43.java`

A Quotation, 쿼테이션 내부에 위치한 문자는 문자의 코드값을 넘겨주므로 해당 코드값에 맞는 문자열타입을 정의할 필요가 없다

- [O] 논리 리터럴을 표현할 수 있다. `ex03/Exam5.java`

A || OR == equal &&= AND 
	A >< B 비교연산

- [O] 문자열 리터럴을 표현할 수 있다. `ex03/Exam6.java`

A	문자'열' 리터럴은 "" double-quotation을 이용해 표현한다, 싱글 쿼테이션에 위치한 문자는 연산식이 해당 문자 뒤에 올 경우
해당 문자를 문자코드-16진수로 변환하여 정수연산을 시행한다, 더블 쿼테이션 내부에 위치한 문자열은 연산식이 올 경우 해당 문자열을 합하여 출력한다

- [O] 문자열과 다른 유형의 데이터를 결합할 때 어떤 결과가 발생하는지 안다. `ex03/Exam6.java`

A 더블쿼테이션 내부에 위치한 문자 열과 다른 데이터를 결합할경우 데이터를 단순히 붙인 문자열이 출력되며 싱글쿼테이션 내부에 위치한 문자와 다른
데이터를 결합할경우 해당 싱글쿼테이션 내부에 위치한 문자를 16진수 문자코드로 변환하여 정수연산을 시행한다.

- [O] 이스케이스 문자의 역할과 사용법을 안다. `ex03/Exam7.java`

A \n, \f등의 escape character는 문자열의 사이에 끼어 특정 명령을 수행하는 동작을 하는 카드다. \뒤에 오는 모든 문자는 이스케이프 문자로 취급된다,
이를 원치않으며 \를 출력하기 위해선 싱글쿼테이션으로 \를 감싸주어야 한다.


#### 변수

- [ ] 변수를 선언할 수 있다. `ex04/Exam11.java`
- [ ] 변수 선언의 의미를 설명할 수 있다. `ex04/Exam11.java`
- [ ] 여러 개의 변수를 한 문장으로 선언할 수 있다. `ex04/Exam111.java`
- [ ] 변수가 가리키는 메모리에 값을 저장할 수 있다. `ex04/Exam12.java`
- [ ] 변수 선언할 때 값을 저장할 수 있다. `ex04/Exam121.java`
- [ ] 한 문장으로 여러 개의 변수를 선언할 때에도 값을 저장할 수 있다. `ex04/Exam122.java`
- [ ] 한 문장으로 여러 개의 변수를 선언할 때 일부 변수만 값을 저장할 수 있다. `ex04/Exam123.java`
- [ ] 변수가 가리키는 메모리의 값을 변경할 수 있다. `ex04/Exam13.java`
- [ ] 블록 안에서 변수를 선언할 수 있는 위치를 안다. `ex04/Exam14.java`
- [ ] 변수를 먼저 사용하고 그 다음에 변수를 선언할 때 발생하는 문제를 안다. `ex04/Exam141.java`
- [ ] 같은 이름의 변수를 중복해서 선언할 때 발생하는 문제를 안다. `ex04/Exam142.java`
- [ ] 변수의 값을 출력할 수 있다. `ex04/Exam15.java`
- [ ] 변수의 값을 다른 변수에 저장할 수 있다. `ex04/Exam151.java`
- [ ] 변수를 초기화시키지 않은 후 사용하면 어떻게 되는지 안다. `ex04/Exam152.java,Exam153.java`
- [ ] 값의 종류에 따라 변수를 선언할 수 있다. `ex04/Exam16.java`
- [ ] primitive data type을 데이터 유형에 따라 크기에 따라 구분할 수 있다. `ex04/Exam16.java`
- [ ] primitive data type 과 referece type을 구분할 수 있다. `ex04/Exam16.java`
- [ ] 정수 데이터 타입(byte, short, int, long)의 각 변수의 메모리 크기와 이 메모리에 저장할 수 있는 최대, 최소 값을 안다. `ex04/Exam21.java`
- [ ] 4바이트와 8바이트 크기의 정수 리터럴을 각 타입의 변수에 저장할 때 규칙을 이해한다. `ex04/Exam22.java`
- [ ] 작은 메모리에 큰 메모리의 값을 넣을 때 어떤 일이 일어나는지 안다. `ex04/Exam23.java`
- [ ] 4바이트 부동소수점 변수에 넣을 수 있는 값의 최대, 최소 크기를 말할 수 있다. `ex04/Exam31.java`
- [ ] 8바이트 부동소수점 변수에 넣을 수 있는 값의 최대, 최소 크기를 말할 수 있다. `ex04/Exam311.java`
- [ ] 단정도, 배정도의 용어를 이해한다. `ex04/Exam311.java`
- [ ] 부동소수점 리터럴의 크기에 따라 적절할 부동소수점 변수를 선언할 수 있다. `ex04/Exam32.java`
- [ ] 잘못된 부동소수점 리터럴을 변수에 저장할 때 어떤 문제가 발생하는지 이해한다. `ex04/Exam321.java`
- [ ] 부동소수점 변수끼리 연산할 때 결과가 부동소수점의 크기를 벗어날 경우 발생되는 문제를 안다. `ex04/Exam322.java`
- [ ] 작은 부동소수점 메모리에 큰 부동소수점 메모리의 값을 넣을 때 발생되는 문제는 안다. `ex04/Exam33.java`
- [ ] UCS-2에 정의된 문자 코드를 저장할 변수를 선언할 수 있다. `ex04/Exam41.java`
- [ ] char 변수에 저장할 수 있는 최대, 최소 값을 말 할 수 있다. `ex04/Exam41.java`
- [ ] char 변수에 문자의 UCS-2 코드 값을 저장하고 출력할 수 있다. `ex04/Exam42.java`
- [ ] char 변수에 저장된 문자 코드를 화면에 출력할 때 문자로 표현하는 과정을 설명할 수 있다. `ex04/Exam42.java`
- [ ] 따옴표를 활용하여 문자의 UCS-2 코드 값을 알아낼 수 있다. `ex04/Exam43.java`
- [ ] 정수를 UCS-2 문자 코드로 인식하게 하여 문자를 출력할 수 있다. `ex04/Exam44.java`
- [ ] - [ ] 논리 값을 담을 변수를 선언할 수 있다. `ex04/Exam51.java`
- [ ] boolean 변수를 JVM 내부에서는 4바이트 int 메모리로 다룬다는 것을 이해한다. `ex04/Exam51.java`
- [ ] boolean 변수에 직접 1과 0을 넣을 수 없음을 안다. `ex04/Exam51.java`
- 